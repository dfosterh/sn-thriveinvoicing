<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_175353_thriveinv.ThriveInvoiceUtil</api_name>
        <client_callable>false</client_callable>
        <description/>
        <name>ThriveInvoiceUtil</name>
        <script><![CDATA[var ThriveInvoiceUtil = Class.create();
ThriveInvoiceUtil.AdjustmentReason = [];

ThriveInvoiceUtil.CalculateInvoice = function(invoice) {
	try {
		var priorDetail = new GlideRecord('x_175353_thriveinv_invoice_details');
		priorDetail.addQuery('invoice', invoice.sys_id);
		priorDetail.addQuery('is_manual_entry', false);
		priorDetail.deleteMultiple();

		var teTotal = 0;
		var mrrTotal = 0;
		var mrrTotalProrates = 0;

		switch (invoice.invoice_type.toString()) {
			case 'TM':
				ThriveInvoiceUtil.SetTimeInvoiced(invoice);
				teTotal = ThriveInvoiceUtil.SetInvoiceDetailsTE(invoice.sys_id);
				break;
			case 'MRR':
				ThriveInvoiceUtil.ReleaseTimeEntries(invoice.sys_id);
				mrrTotal = ThriveInvoiceUtil.SetInvoiceDetailsMRR(invoice.sys_id, invoice.customer.sys_id, invoice.invoice_date);
				if(invoice.include_prorated_provisions) {
					mrrTotalProrates = ThriveInvoiceUtil.SetInvoiceDetailsMRRProratedAdds(invoice.sys_id, invoice.customer.sys_id, invoice.invoice_date);
				}
				break;
			case 'MRRP':
				ThriveInvoiceUtil.ReleaseTimeEntries(invoice.sys_id);
				mrrTotalProrates = ThriveInvoiceUtil.SetInvoiceDetailsMRRProratedAdds(invoice.sys_id, invoice.customer.sys_id, invoice.invoice_date);
				break;
			case 'project':
				gs.addErrorMessage('I don\'t know how to calculate projects yet.');
				break;
		}
		
		gs.debug(gs.getMessage('Invoice detail records generated for type {0}.', [invoice.invoice_type]));
		
		var inv = new GlideRecord('x_175353_thriveinv_invoices');
		inv.get(invoice.sys_id);
		inv.tm_total = teTotal;
		inv.mrr_total = mrrTotal;
		inv.prorate_total = mrrTotalProrates;
		inv.adjustment_total = ThriveInvoiceUtil.GetManualAdjustmentTotal(invoice.sys_id);

		inv.update();
	}
	catch(ex) {
		gs.addErrorMessage('Error in ThriveInvoiceUtil.SetInvoiceDetails: ' + ex.message);
	}
};

ThriveInvoiceUtil.ReleaseTimeEntries = function(invoiceID) {
	try {
		var te = new GlideRecord('task_time_worked');
		te.addQuery('x_175353_thriveinv_invoice', invoiceID);
		te.setValue('x_175353_thriveinv_invoice', null);
		te.updateMultiple();
	}
	catch(ex) {
		gs.addErrorMessage('Error in ThriveInvoiceUtil.SetInvoiceDetails: ' + ex.message);
	}};

ThriveInvoiceUtil.GetManualAdjustmentTotal = function(invoiceID) {
	try {
		var adj = new GlideAggregate('x_175353_thriveinv_invoice_details');
		adj.addQuery('invoice', invoiceID);
		adj.addQuery('is_manual_entry', true);
		adj.addAggregate('SUM', 'billed_amount');
//default?		adj.setGroup(false);
		adj.query();
		
		var returnValue = 0;
		while (adj.next()) {
			returnValue = adj.getAggregate('SUM', 'billed_amount');
		}
		
		return returnValue;
	}
	catch(ex) {
		gs.addErrorMessage('Error in ThriveInvoiceUtil.GetAdjustmentTotal: ' + ex.message);
	}
};

ThriveInvoiceUtil.SetInvoiceDetailsTE = function(invoiceID) {
	try {
		var te = new GlideRecord('task_time_worked');
		te.addQuery('x_175353_thriveinv_invoice', invoiceID);
		te.query();

		var returnValue = 0;
		while (te.next()) {
			var detail = new GlideRecord('x_175353_thriveinv_invoice_details');
			detail.initialize();
			
			detail.is_manual_entry = false;
			detail.invoice = invoiceID;
//			detail.time_entry = te.sys_id;
			detail.sourceidlink = '/task_time_worked.do?sys_id=' + te.sys_id;
			detail.item = 'Time Entry';
			detail.detail = te.comments;
			detail.billed_quantity = te.x_175353_thriveinv_billed_hours;
			detail.billed_rate = te.x_175353_thriveinv_billed_rate;
			detail.billed_amount = PerfectRound(te.x_175353_thriveinv_billed_hours * te.x_175353_thriveinv_billed_rate, 2);
			returnValue += PerfectRound(detail.billed_amount, 2);
			
			detail.insert();
		}

		gs.debug(gs.getMessage('TE Invoice detail records generated for {0}.', [returnValue]));
		
		return returnValue;
	}
	catch(ex) {
		gs.addErrorMessage('Error in ThriveInvoiceUtil.SetInvoiceDetails: ' + ex.message);
	}
};

ThriveInvoiceUtil.SetInvoiceDetailsMRR = function(invoiceID, companyID, invoiceDate) {
	try {
		endPeriodDate = GetEOM(invoiceDate, -1);
		gs.debug(gs.getMessage('Calculating RMM provisioned by {0}', [endPeriodDate]));

		//OOB entitlement-contract relationship does not cascade delete. Need to make sure contract is still active
		var mrr = new GlideAggregate('x_175353_contracts_m2m_configuratio_entitlements');
		mrr.addQuery('entitlement.contract.account.sys_id', companyID);
		mrr.addQuery('entitlement.contract.state', 'Active');
		//Not using x_175353_contracts_provisioned_qty because current count is not the same as count prior to this month
		mrr.addQuery('date_provisioned', '<=', endPeriodDate.getDate().getDisplayValue());
		mrr.addAggregate('COUNT');
		mrr.setGroup(true);
		mrr.groupBy('entitlement');
		mrr.query();

		var returnValue = 0;
		var qty = 0;
		
		while (mrr.next()) {
			if (mrr.entitlement.x_175353_contracts_bill_contracted_qty) {
				qty = mrr.entitlement.x_175353_contracts_contract_quantity;
			}
			else {
				qty = mrr.getAggregate('COUNT');
			}
			
			var detail = new GlideRecord('x_175353_thriveinv_invoice_details');
			detail.initialize();
			
			detail.is_manual_entry = false;
			detail.invoice = invoiceID;
			detail.sourceidlink = '/service_entitlement.do?sys_id=' + mrr.entitlement.sys_id;
			var sku = mrr.entitlement.x_175353_contracts_business_service.name;
			var desc = mrr.entitlement.x_175353_contracts_description;
			detail.item =  sku + ': ' + desc;
			detail.detail = 'Billed for next month';
			detail.billed_quantity = qty;
			detail.billed_rate = mrr.entitlement.x_175353_contracts_contracted_price;
			detail.billed_amount = PerfectRound(qty * mrr.entitlement.x_175353_contracts_contracted_price, 2);
			returnValue += PerfectRound(detail.billed_amount, 2);
			
			detail.insert();
		}

		gs.debug(gs.getMessage('MRR Invoice detail records generated for {0}.', [returnValue]));
		
		return returnValue;
	}
	catch(ex) {
		gs.addErrorMessage('Error in ThriveInvoiceUtil.SetInvoiceDetails: ' + ex.message);
	}
};

ThriveInvoiceUtil.SetInvoiceDetailsMRRProratedAdds = function(invoiceID, companyID, invoiceDate) {
	try {
		/*
		TODO: What if SKU/Device pair on prior period invoice, which means this month is already paid for?
			This will happen, but could be an acceptible initial bug. Need test data spanning multiple months
		*/
		var startPeriodDate = GetBOM(invoiceDate, -1);
		var endPeriodDate = GetEOM(invoiceDate, -1);
		gs.debug(gs.getMessage('Calculating prorated provisionings for {0} - {1}', [startPeriodDate, endPeriodDate]));

		var mrra = new GlideAggregate('x_175353_contracts_entitlement_history');
		mrra.addQuery('company.sys_id', companyID);
		mrra.addQuery('entitlement.contract.state', 'Active');
		mrra.addQuery('event', '!=', 'delete');
		mrra.addQuery('date_provisioned', '>=', startPeriodDate.getDate().getDisplayValue());
		mrra.addQuery('date_provisioned', '<=', endPeriodDate.getDate().getDisplayValue());
		mrra.addQuery('ci_entitlement.date_provisioned', '>=', startPeriodDate.getDate().getDisplayValue());
		mrra.addQuery('ci_entitlement.date_provisioned', '<=', endPeriodDate.getDate().getDisplayValue());
		//this assumes it's a CI entitlement. Also, will need to be sensitive to include_prorated_deprovisions if we implement that
		mrra.addNotNullQuery('ci_entitlement');
		mrra.setGroup(true);
		mrra.groupBy('entitlement');
		mrra.groupBy('granted_to_sys_id');
		mrra.addAggregate('MIN', 'date_provisioned');
		mrra.query();
		
		var returnValue = 0;
		while (mrra.next()) {
			if(mrra.entitlement.x_175353_contracts_bill_contracted_qty) {
				continue;
			}

			var mrrp = new GlideRecord('x_175353_contracts_entitlement_history');
			mrrp.addQuery('event', '!=', 'delete');
			mrrp.addQuery('entitlement_sys_id', mrra.entitlement.sys_id);
			mrrp.addQuery('granted_to_sys_id', mrra.granted_to_sys_id);
			mrrp.addQuery('date_provisioned', mrra.getAggregate('MIN', 'date_provisioned').substring(0, 10));
			mrrp.query();
			
			if(mrrp.next()) {
//what if earliest provision history date is before current M2M provision date. Which wins?
				var dtProvisioned = new GlideDateTime(mrrp.date_provisioned.getDisplayValue() + ' 12:00:00');
				var totalDays = dtProvisioned.getDaysInMonthLocalTime();
				var day = dtProvisioned.getDayOfMonthLocalTime();
				var rate = (totalDays - day + 1) / totalDays;

				var detail = new GlideRecord('x_175353_thriveinv_invoice_details');
				detail.initialize();

				detail.is_manual_entry = false;
				detail.invoice = invoiceID;
				detail.sourceidlink = '/service_entitlement.do?sys_id=' + mrrp.entitlement.sys_id;
				var sku = mrrp.business_service_name;
				var desc = mrrp.entitlement_description;
				detail.item = sku + ': ' + desc;
				detail.detail = 'Provisioned to ' + mrrp.granted_to_name + ' on ' + mrrp.date_provisioned.toString();
				detail.billed_quantity = rate;
				detail.billed_rate = mrrp.contracted_price;
				detail.billed_amount = PerfectRound(rate * mrrp.contracted_price, 2);
				returnValue += PerfectRound(detail.billed_amount, 2);

				detail.insert();
			}
		}

		gs.debug(gs.getMessage('MRR Prorated Added Invoice detail records generated for {0}.', [returnValue]));
		
		return returnValue;
	}
	catch(ex) {
		gs.addErrorMessage('Error in ThriveInvoiceUtil.SetInvoiceDetails: ' + ex.message);
	}
};

ThriveInvoiceUtil.SetTimeInvoiced = function(invoice) {
	try {
		var te = new GlideRecord('task_time_worked');
//add Service Location filter
		var qry = gs.getMessage('task.sys_domain={0}^x_175353_thriveinv_invoiceISEMPTY^ORx_175353_thriveinv_invoice={1}', [invoice.sys_domain, invoice.sys_id]);
		te.addQuery(qry);
		te.query();

		while (te.next()) {
			var wrRate = ThriveInvoiceUtil.GetWorkRoleRate(1, te.x_175353_thriveinv_work_role, te.task.company, null, te.task.parent);
			if(!wrRate) {
				te.x_175353_thriveinv_has_billing_issue = true;
				te.x_175353_thriveinv_adjustment_reason = 'Failed to get Work Role rate';
			}
			
			var workType = ThriveInvoiceUtil.GetWorkType(2, te.x_175353_thriveinv_work_type, te.task.company, null, te.task.parent);
			if(!workType) {
				te.x_175353_thriveinv_has_billing_issue = true;
				te.x_175353_thriveinv_adjustment_reason = 'Failed to get Work Type';
			}
			
			if(wrRate && workType) {
				te.x_175353_thriveinv_invoice = invoice.sys_id;
				te.x_175353_thriveinv_billed_rate = ThriveInvoiceUtil.GetBilledRate(3, wrRate, workType);
				te.x_175353_thriveinv_billed_hours = ThriveInvoiceUtil.GetBilledHours(4, te.time_in_seconds, workType);
				te.x_175353_thriveinv_adjustment_reason = ThriveInvoiceUtil.AdjustmentReason.sort(function(a, b) {
					return a.order - b.order;
				}).map(function(a) {
					return a.value;
				}).join("; ");

				//for some reason, clearing this at the beginning does not work. Need to clear it after I'm done like this
				ThriveInvoiceUtil.AdjustmentReason.length = 0;

				te.x_175353_thriveinv_has_billing_issue = false;
			}

			
			
			te.update();
		}

		gs.debug(gs.getMessage('All non-invoiced Time Worked records have been updated with invoice details.'));
	}
	catch(ex) {
		gs.addErrorMessage('Error in ThriveInvoiceUtil.SetTimeInvoiced: ' + ex.message);
	}
};
	
ThriveInvoiceUtil.GetBilledRate = function(messageOrder, wrRate, workType) {
	var returnValue;

	switch(workType.price_adjustment_type.toString()) {
		case 'adjustment':
			returnValue = parseFloat(wrRate) + parseFloat(workType.price_adjustment);
			ThriveInvoiceUtil.AdjustmentReason.push({
				order: messageOrder,
				value: gs.getMessage('Rate adjusted by ${0} from Work Type', [workType.price_adjustment.toString()])
			});
			break;
		case 'multiplier':
			returnValue = wrRate * workType.price_adjustment;
			ThriveInvoiceUtil.AdjustmentReason.push({
				order: messageOrder,
				value: gs.getMessage('Rate multiplied by {0} from Work Type', [workType.price_adjustment.toString()])
			});
			break;
		case 'override':
			returnValue = workType.price_adjustment;
			ThriveInvoiceUtil.AdjustmentReason.push({
				order: messageOrder,
				value: gs.getMessage('Rate overridden to ${0} from Work Type', [workType.price_adjustment.toString()])
			});
			break;
		default:
			gs.addErrorMessage('There is a Price Adjustment Type in Work Types that does not yet have a calculation.');
	}

	return returnValue;
};

ThriveInvoiceUtil.GetBilledHours = function(messageOrder, teSeconds, workType) {
	//1st minute is not counted. We can make it first 30-seconds with round, or just let any second over round up
	var teMinutes = Math.floor(teSeconds / 60);

	if(workType.round_to_minutes && workType.round_to_minutes > 0) {
		//round up
		if (teMinutes % workType.round_to_minutes > 0) {
			teMinutes = workType.round_to_minutes * (Math.floor(teMinutes / workType.round_to_minutes) + 1);
		}

		ThriveInvoiceUtil.AdjustmentReason.push({
			order: messageOrder,
			value: gs.getMessage('Hours rounded to the nearest {0} minutes from Work Type', [workType.round_to_minutes.toString()])
		});	}

	return teMinutes / 60;
};

ThriveInvoiceUtil.GetWorkRoleRate = function(messageOrder, workRoleId, companyId, contractId, projectId) {
	if(!workRoleId) {
		gs.addErrorMessage('There is a Time Entry with no Work Role selected.');
		return null;
	}
	
	var wrRate;
	
//RISK: projectId is parent. Need to check class or other attribute to make sure this is pointing to a project. What about nested tasks? Also need to make sure Company does not get picked up off of project/contract overrides.
	if (projectId) {
		 wrRate = ThriveInvoiceUtil.GetWorkRoleRateForProject(workRoleId, projectId);
	}
	
	if (wrRate) {
		ThriveInvoiceUtil.AdjustmentReason.push({
			order: messageOrder,
			value: gs.getMessage('Work Role rate ${0} from Project Override', [wrRate])
		});
	}
	else {
		if (companyId) {
			wrRate = ThriveInvoiceUtil.GetWorkRoleRateForCompany(workRoleId, companyId);
		}
	
		if (wrRate) {
			ThriveInvoiceUtil.AdjustmentReason.push({
				order: messageOrder,
				value: gs.getMessage('Work Role rate ${0} from Company Override', [wrRate])
			});
		}
		else {
			wrRate = ThriveInvoiceUtil.GetWorkRoleRateDefault(workRoleId);
			ThriveInvoiceUtil.AdjustmentReason.push({
				order: messageOrder,
				value: gs.getMessage('Default Work Role rate ${0}', [wrRate])
			});
		}
	}
	
	return wrRate;
};

ThriveInvoiceUtil.GetWorkType = function(messageOrder, workTypeId, companyId, contractId, projectId) {
	if(!workTypeId) {
		gs.addErrorMessage('There is a Time Entry with no Work Type selected.');
		return null;
	}

	var returnValue;
	
	if (projectId) {
		 returnValue = ThriveInvoiceUtil.GetWorkTypeForProject(workTypeId, projectId);
	}
	
	if (returnValue) {
		ThriveInvoiceUtil.AdjustmentReason.push({
			order: messageOrder,
			value: gs.getMessage('Work Type from Project Override')
		});
	}
	else {
		if(companyId) {
			returnValue = ThriveInvoiceUtil.GetWorkTypeForCompany(workTypeId, companyId);
		}
		
		if (returnValue) {
			ThriveInvoiceUtil.AdjustmentReason.push({
				order: messageOrder,
				value: gs.getMessage('Work Type from Company Override')
			});
		}
		else {
			returnValue = ThriveInvoiceUtil.GetWorkTypeDefault(workTypeId);
			ThriveInvoiceUtil.AdjustmentReason.push({
				order: messageOrder,
				value: gs.getMessage('Work Type from Default')
			});
		}
	}

	return returnValue;
};

ThriveInvoiceUtil.GetWorkRoleRateForProject = function(workRoleId, projectId) {
	var wr = new GlideRecord('x_175353_thriveinv_labor_rate_card_overrides');
	wr.addQuery('overridden_work_role', workRoleId);
	wr.addQuery('project', projectId);
	wr.query();

	if(wr.next()) {
		return wr.hourly_rate;
	}
};

ThriveInvoiceUtil.GetWorkRoleRateForCompany = function(workRoleId, companyId) {
	var wr = new GlideRecord('x_175353_thriveinv_labor_rate_card_overrides');
	wr.addQuery('overridden_work_role', workRoleId);
	wr.addQuery('company', companyId);
	wr.addQuery('contract', null);
	wr.addQuery('project', null);
	wr.query();

	if(wr.next()) {
		return wr.hourly_rate;
	}
};

ThriveInvoiceUtil.GetWorkRoleRateDefault = function(workRoleId) {
	var wr = new GlideRecord('fm_labor_rate_card');
	wr.get(workRoleId);
	return wr.hourly_rate;
};

ThriveInvoiceUtil.GetWorkTypeForProject = function(workTypeId, projectId) {
	var wt = new GlideRecord('x_175353_thriveinv_work_type_overrides');
	wt.addQuery('overridden_work_type', workTypeId);
	wt.addQuery('project', projectId);
	wt.query();

	if(wt.next()) {
		return wt;
	}
};

ThriveInvoiceUtil.GetWorkTypeForCompany = function(workTypeId, companyId) {
	var wt = new GlideRecord('x_175353_thriveinv_work_type_overrides');
	wt.addQuery('overridden_work_type', workTypeId);
	wt.addQuery('company', companyId);
	wt.addQuery('contract', null);
	wt.addQuery('project', null);
	wt.query();

	if(wt.next()) {
		return wt;
	}
};

ThriveInvoiceUtil.GetWorkTypeDefault = function(workTypeId) {
	var wt = new GlideRecord('x_175353_thriveinv_work_types');
	wt.get(workTypeId);
	return wt;
};

function PerfectRound(num, places) {
	return + (Math.round(num + "e+" + places)  + "e-" + places);
}

function GetEOM(date, offset) {
	var returnValue = new GlideDateTime(date);
	returnValue.addMonthsUTC(offset);
	returnValue.setDayOfMonthUTC(32);
	
	return returnValue;
}

function GetBOM(date, offset) {
	var returnValue = new GlideDateTime(date);
	returnValue.addMonthsUTC(offset);
	returnValue.setDayOfMonthUTC(1);
	
	return returnValue;
}
]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2018-08-13 19:35:01</sys_created_on>
        <sys_id>ce2ab99f4fb313002e7e8020a310c743</sys_id>
        <sys_mod_count>348</sys_mod_count>
        <sys_name>ThriveInvoiceUtil</sys_name>
        <sys_package display_value="Thrive Invoices" source="x_175353_thriveinv">d742b9934f3313002e7e8020a310c7e3</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Thrive Invoices">d742b9934f3313002e7e8020a310c7e3</sys_scope>
        <sys_update_name>sys_script_include_ce2ab99f4fb313002e7e8020a310c743</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2018-10-10 14:34:20</sys_updated_on>
    </sys_script_include>
</record_update>
